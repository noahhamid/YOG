generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum UserRole {
  USER
  SELLER
  ADMIN
}

enum ProductStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum ProductCategory {
  MEN
  WOMEN
  UNISEX
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
}

enum DeliveryMethod {
  DELIVERY
  MEETUP
}

model Review {
  id        String   @id @default(cuid())
  productId String
  userId    String
  userName  String
  userEmail String
  rating    Int      // 1-5 stars
  comment   String   @db.Text
  helpful   Int      @default(0) // Count of helpful votes
  verified  Boolean  @default(false) // Verified purchase
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([productId])
  @@index([userId])
  @@index([rating])
}


model Order {
  id             String         @id @default(cuid())
  orderNumber    String         @unique
  
  // Customer Info
  customerName   String
  customerPhone  String
  customerEmail  String?
  
  // Product Info
  productId      String
  sellerId       String
  quantity       Int
  selectedSize   String
  selectedColor  String
  
  // Pricing
  unitPrice      Float
  totalPrice     Float
  deliveryFee    Float          @default(0)
  finalTotal     Float
  
  // Delivery
  deliveryMethod DeliveryMethod
  deliveryAddress String?       @db.Text
  
  // Status
  status         OrderStatus    @default(PENDING)
  notes          String?        @db.Text
  
  // Timestamps
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  
  // Relations
  product        Product        @relation(fields: [productId], references: [id], onDelete: Cascade)
  seller         Seller         @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  
  // OPTIMIZED INDEXES
  @@index([sellerId, status]) // Composite index for filtering by seller + status
  @@index([sellerId, createdAt]) // For sorting by date
  @@index([productId])
  @@index([orderNumber])
}

model User {
  id        String   @id @default(cuid())
  name      String
  email     String   @unique
  phone     String?  @unique  // Make phone optional for OAuth users
  password  String?  // Make password optional for OAuth users
  role      UserRole @default(USER)
  
  // OAuth fields
  provider  String?  // "google", "credentials", etc.
  providerId String? // Google ID, etc.
  image     String?  // Profile picture from OAuth
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  seller Seller?
  reviews Review[]
  
  @@index([email])
  @@index([phone])
  @@index([provider])
}

model Seller {
  id              String   @id @default(cuid())
  userId          String   @unique
  brandName       String
  ownerName       String
  phone           String
  email           String
  instagram       String?
  location        String
  clothingType    String
  businessType    String
  experience      String?
  description     String?  @db.Text
  approved        Boolean  @default(false)
  rejectionReason String?  @db.Text
  
  // Store customization - UPDATED FOR BASE64 IMAGES
  storeSlug       String?  @unique
  storeLogo       String?  @db.Text  // ✅ Changed to Text for base64
  storeCover      String?  @db.Text  // ✅ Changed to Text for base64
  storeDescription String? @db.Text
  orders   Order[] 
  
  // Analytics
  followers       Int      @default(0)
  totalViews      Int      @default(0)
  totalSales      Int      @default(0)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  products      Product[]
  followersList Follow[]  @relation("SellerFollowers")

  @@index([userId])
  @@index([approved])
  @@index([storeSlug])
}

model Follow {
  id        String   @id @default(cuid())
  userId    String
  sellerId  String
  createdAt DateTime @default(now())

  seller Seller @relation("SellerFollowers", fields: [sellerId], references: [id], onDelete: Cascade)

  @@unique([userId, sellerId])
  @@index([userId])
  @@index([sellerId])
}

model Product {
  id              String          @id @default(cuid())
  sellerId        String
  title           String
  description     String          @db.Text
  price           Float
  compareAtPrice  Float?
  category        ProductCategory
  brand           String?
  status          ProductStatus   @default(DRAFT)
  isFeatured      Boolean         @default(false)
  isTrending      Boolean         @default(false)
  tags            String[]
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  seller   Seller           @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  variants ProductVariant[]
  images   ProductImage[]
  orders   Order[]
  reviews  Review[]
  
  // ✅ OPTIMIZED INDEXES
  @@index([sellerId, status]) // Compound index
  @@index([status, category]) // For filtering published by category
  @@index([isFeatured, status]) // For featured products
  @@index([isTrending, status]) // For trending products
  @@index([createdAt]) // For sorting by date
  @@index([category, status, createdAt]) // Compound for common query
}

model ProductVariant {
  id        String  @id @default(cuid())
  productId String
  size      String
  color     String
  quantity  Int
  sku       String?

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([productId])
}

model ProductImage {
  id        String @id @default(cuid())
  productId String
  url       String
  position  Int

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([productId])
}